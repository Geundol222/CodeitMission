# -*- coding: utf-8 -*-
"""미션2_2팀_이현석.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IPCdQHNQFlKDqr35qMYR91ECzZ4TOypd

| 컬럼명                              | 설명                                                  |
| -------------------------------- | --------------------------------------------------- |
| hotel                          | 호텔 이름 (Resort Hotel 또는 City Hotel)                  |
| is_canceled                    | 예약 취소 여부 (1: 취소됨, 0: 취소되지 않음)                       |
| lead_time                      | 예약일로부터 체크인까지 남은 일수                                  |
| arrival_date_year              | 고객 도착 연도                                            |
| arrival_date_month             | 고객 도착 월                                             |
| arrival_date_week_number       | 고객 도착 주차 (예: 3 = 3주차)                               |
| arrival_date_day_of_month      | 고객 도착 일자 (예: 2 = 2일)                                |
| stays_in_weekend_nights        | 주말(토~일) 숙박일 수                                      |
| stays_in_week_nights           | 주중(월~금) 숙박일 수                                      |
| adults                         | 어른 인원 수                                             |
| children                       | 어린이 인원 수                                            |
| babies                         | 아기 인원 수                                             |
| meal                           | 식사 옵션                                               |
|  ├ Undefined, SC             | 식사 미포함                                              |
|  ├ BB                          | Bed & Breakfast (조식 포함)                             |
|  ├ HB                          | Half Board (조식 + 1식)                                |
|  └ FB                          | Full Board (조식 + 중식 + 석식)                           |
| country                        | 투숙객의 국가 (ISO 3166-1 alpha-3 코드)                     |
| market_segment                 | 시장 세그먼트 (TA: Travel Agent, TO: Tour Operator 등) |
| distribution_channel           | 예약 유통 채널 (TA, TO 등)                             |
| is_repeated_guest              | 반복 방문 여부 (1: 재방문, 0: 첫 방문)                          |
| previous_cancellations         | 이전 예약 취소 횟수                                         |
| previous_bookings_not_canceled | 이전 비취소 예약 횟수                                        |
| reserved_room_type             | 예약한 객실 유형 코드                                        |
| assigned_room_type             | 실제 배정된 객실 유형 코드                                     |
| booking_changes                | 예약 변경 횟수                                            |
| agent                          | 예약한 여행사 ID                                          |
| company                        | 예약자 소속 회사 또는 단체 ID                                  |
| days_in_waiting_list           | 대기 명단에 있던 일수                                        |
| required_car_parking_spaces    | 요청한 주차 공간 수                                         |
| total_of_special_requests      | 특별 요청 건수 (예: 아기침대, 고층 등)                            |
| reservation_status             | 최종 예약 상태                                            |
|  ├ Canceled                    | 예약 취소됨                                              |
|  ├ Check-Out                   | 정상적으로 투숙 후 체크아웃                                     |
|  └ No-Show                     | 노쇼 (체크인하지 않음)                                       |
| reservation_status_date        | 최종 상태가 설정된 날짜                                       |
"""

# 드라이브 마운트 코드
from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

df = pd.read_csv("/content/drive/MyDrive/Codeit/hotel_data_modified.csv")
df

df.describe()

df.info()

"""## 1. 첫번째 가설

- required_car_parking_spaces (고객이 요구하는 주차공간의 수가 부족할 경우)
- total_of_special_requests (고객의 특별요청이 받아들여지지 않았을 경우)
- reserved_room_type / assigned_room_type (호텔 사정으로 고객이 예약한 룸타입의 변경이 존재할 경우)
- describe 확인결과 required_car_parking_spaces와 total_of_special_requests모두 중앙값이 0이고 평균이 0.대 인것으로 보아 유의미한 상관관계가 있을지 의심되지만 가장 직관적인 데이터라고 생각하므로 우선적으로 분석진행
"""

# 중복값 확인
df.duplicated().sum()

# 중복값 제거
df = df.drop_duplicates()
df.duplicated().sum()

# 결측치 확인
df.isnull().sum()

df.describe()

# 최종 데이터 확인용 dict
cancel_result = {}

"""### 데이터 검증"""

# 의심되는 데이터들의 데이터 적합성 판단

import matplotlib.pyplot as plt
import seaborn as sns

# 방데이터는 범주형이므로 일단 제외
selected_cols = ['is_canceled', 'required_car_parking_spaces', 'total_of_special_requests']

plt.figure(figsize=(10,10))

for i, col in enumerate(selected_cols, 1):
  plt.subplot(3, 3, i)
  plt.boxplot(df[col].dropna())
  plt.title(f"{col}")

plt.tight_layout()
plt.show()

"""### 예약된 방과 배정된 방이 다른 경우"""

# 범주형 데이터인 룸 관련 데이터를 변환 - 자신이 예약한 방과 동일한 방이 배정 되었는가?

df['is_same_to_reservation'] = df['reserved_room_type'] == df['assigned_room_type']
df.head()

"""### 상관계수 분석"""

cols = ['is_canceled', 'required_car_parking_spaces', 'total_of_special_requests', 'is_same_to_reservation']
corr = df[cols].corr()    # 상관관계 계산

plt.figure(figsize=(15, 11))
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title("Correlation")
plt.show()

"""### 상관 관계를 보이는 데이터들의 취소율 비교"""

# 상관계수가 0.22 인 is_same_to_reservation의 취소율 통계
same_room = df.groupby('is_same_to_reservation')['is_canceled'].mean()
same_room

"""### 상관관계 이외의 요소에서 데이터 검증"""

special_requests_cut = pd.cut(
    df['total_of_special_requests'],
    bins=[-0.1, 0.5, 6],
    labels=['0', '1+']
)

special_requests = df.groupby(special_requests_cut)['is_canceled'].mean()
special_requests

car_space_cut = pd.cut(
    df['required_car_parking_spaces'],
    bins=[-0.1, 0.5, 6],
    labels=['0', '1+']
)

car_space = df.groupby(car_space_cut)['is_canceled'].mean()
car_space

cancel_result['is_not_same_room'] = 0.32

"""### 첫번째 가설 검증결과

* 자신이 예약한 방과 다른 방이 배정되었을 경우가 그나마 0.22로 약한 양의 상관관계가 있는 것으로 판명되고, 전체 취소율 평균 0.27에 비해 방이 바뀌었을 때 취소율 평균이 0.32이므로 예약한 방과 다른 방이 배정되었을 경우 취소율이 증가하는 경향성은 확인할 수 있음. 나머지 경우에서는 유의미한 상관관계가 발견되지 않음

### 원인분석:
- isnull() 분석결과 각 컬럼에서는 결측치를 발견하지 못했으므로 결측치에 의한 오차가 아님

- 고객들이 요구사항이 별로 없었음, 예를들어 주차공간의 boxplot의 경우 주차공간을 필요로하는 인원은 소수이며 나머지는 대부분 주차가 필요하지 않았음

- 특별한 요구사항의 경우도 이상치를 제외하면 2건까지는 요구한 것으로 보이나, 중앙값이 0인 것으로 보아 고객들의 특별 요구사항도 적었을 것으로 판단됨

---

## 2. 두번째 가설
- days_in_waiting_list (고객이 예약 대기를 기다릴 수 없거나 예약 대기가 오래 걸렸을 경우)
- previous_cancellations (고객의 상습적인 예약 취소일 경우)
- market_segment (세그먼트상 호텔의 특성이 자신과 맞지 않을 경우)

### 시장 세그먼트
"""

df['market_segment']

df['distribution_channel']

# 특정 채널에서의 취소율 확인
channel_group = df.groupby('distribution_channel')['is_canceled'].mean()
channel_group

# 특정 세그먼트에서의 취소율 확인
segment_group = df.groupby('market_segment')['is_canceled'].mean()
segment_group

# 각 취소율 통계중 전체 취소율(0.27)을 넘어가는 항목에 대해서 통합 후 파생변수 생성
sort_segment = (df['market_segment'] == 'Online TA') | (df['market_segment'] == 'Groups') | (df['market_segment'] == 'Undefined')
sort_channel = (df['distribution_channel'] == 'TA/TO') | (df['distribution_channel'] == 'Undefined')
df['is_segment_OTA'] = sort_segment & sort_channel
df.head()

"""### 대기기간과 취소 빈도"""

selected_cols = ['days_in_waiting_list ', 'previous_cancellations ']

plt.subplot(1, 2, 1)
plt.boxplot(df['days_in_waiting_list'].dropna())
plt.title("days_in_waiting_list")

plt.subplot(1, 2, 2)
plt.boxplot(df['previous_cancellations'].dropna())
plt.title("previous_cancellations")

plt.tight_layout()
plt.show()

# 이상치 판단을 위한 Z-score

standardizated_waiting_days = (df['days_in_waiting_list'] - df['days_in_waiting_list'].mean()) / df['days_in_waiting_list'].std()

df['is_waiting_days_standard'] = (standardizated_waiting_days > -3) & (standardizated_waiting_days < 3)

standardizated_prev_cancle = (df['previous_cancellations'] - df['previous_cancellations'].mean()) / df['previous_cancellations'].std()

df['is_prev_cancle_standard'] = (standardizated_prev_cancle > -3) & (standardizated_prev_cancle < 3)
df.head()

df_filtered = df[
    df['is_waiting_days_standard'] &
    df['is_prev_cancle_standard']
]

selected_cols = ['days_in_waiting_list', 'previous_cancellations']

plt.subplot(1, 2, 1)
plt.boxplot(df_filtered['days_in_waiting_list'].dropna())
plt.title("days_in_waiting_list")

plt.subplot(1, 2, 2)
plt.boxplot(df_filtered['previous_cancellations'].dropna())
plt.title("previous_cancellations")

plt.tight_layout()
plt.show()

"""### 상관계수 분석"""

filtered_df = df[(df['is_prev_cancle_standard']) & (df['is_waiting_days_standard'])]

cols = ['is_canceled', 'is_segment_OTA', 'previous_cancellations', 'days_in_waiting_list']
corr = filtered_df[cols].corr()    # 상관관계 계산

plt.figure(figsize=(15, 11))
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title("Correlation")
plt.show()

"""### 상관 관계를 보이는 데이터들의 취소율 비교"""

# 상관계수가 0.23 인 is_segment_OTA의 취소율 통계
segment = df.groupby('is_segment_OTA')['is_canceled'].mean()
segment

# 상관계수는 약하지만, 확실한 통계를 위해 취소 빈도수별 취소율 비교
prev_cancel_count = df['previous_cancellations'].value_counts()
prev_cancel_count

prev_cancel = df.groupby('previous_cancellations')['is_canceled'].mean()
prev_cancel

# prev_cancel = 0인 그룹
grp_0 = df[df['previous_cancellations'] == 0]
grp_0_cancel_count = grp_0['is_canceled'].sum()

# prev_cancel >= 1인 그룹
grp_1p = df[df['previous_cancellations'] >= 1]
grp_1p_cancel_count = grp_1p['is_canceled'].sum()

# 전체 취소 건수
total_cancel = df['is_canceled'].sum()

print(f"0인 그룹 취소건수: {grp_0_cancel_count}")
print(f"1+인 그룹 취소건수: {grp_1p_cancel_count}")
print(f"전체 대비 1+ 그룹 비중: {grp_1p_cancel_count/total_cancel:.2%}")

prev_cancel_cut = pd.cut(
    df['previous_cancellations'],
    bins=[-0.1, 0.5, 27],
    labels=['0', '1+']
)

prev_cancel_group = df.groupby(prev_cancel_cut)['is_canceled'].mean()
prev_cancel_group

"""### 상관관계 이외의 요소에서 데이터 검증"""

standard_date = df[(df['days_in_waiting_list']) & (df['is_waiting_days_standard'])]

standard_date

standard_date_cut = pd.cut(
    standard_date['days_in_waiting_list'],
    bins=[0, 5, 30],
    labels=['0-5', '6+']
)
wait_cancel = standard_date.groupby(standard_date_cut)['is_canceled'].mean()
wait_cancel

wait_filter = standard_date[standard_date['days_in_waiting_list'] > 5]
wait_filter['days_in_waiting_list'].count()

# 5일 이상의 인원이 전체 그룹대비 비율이 너무 적음 인사이트로서 적절치 않다고 판단
wait_num = wait_filter['days_in_waiting_list'].count()
total_num = df['days_in_waiting_list'].count()
rate = wait_num / total_num
rate

cancel_result['market_segment_and_channel'] = 0.35

"""### 두번째 가설 검증 결과
* 취소율 평균이 높은 세그먼트 그룹이면서 취소율 높은 채널의 교집합을 기준으로 상관관계 분석 결과 0.23으로 약한 양의 상관관계를 보이는 것으로 나타났음  
상관관계는 크게 높지 않으나 특정 세그먼트 성향 사람들의 취소율 평균은 0.35로 전체 취소율 평균 0.27를 8%p정도 상회하므로 특정 세그먼트의 고객이 취소를 많이하는 경향성을 볼 수 있음
* 이상치의 문제로 Z-score를 통해 이상치를 걸러낸 값으로 previous_cancellations와 days_in_waiting_list도 비교했으나 상관관계가 명확하지 않음
* 하지만, 취소 빈도수의 경우 한번도 취소하지 않은 사람과 1번이상 취소한 사람의 비교를 통해 예전에 한번이라도 취소해 본적 있는 고객의 취소율이 0.68로, 취소경험자의 취소율이 높은 경향성이 확인됨
* 따라서 첫번째 가설과 두번째 가설에 따라, 예약한 방이 바뀌었을 때와 특정 세그먼트 성향인 사람의 예약 취소율이 약하게 나마 예약 취소와 상관이 있을 가능성, 한 번이상 취소를 경험해본 고객들이 조금 더 자주 취소를 할 수 있다는 가능성이 보임

### 원인 분석:
* 고객의 입장에서 대기기간이 5일 이상으로 길어지는 빈도가 적고, 대기기간이 길어지는 것이 충분히 안내가 되었으며 고려사항에 포함되어있을 확률이 높음

---

## 3. 세번째 가설
- country (특정 국가의 사람들이 취소를 많이하는 경향이 있을 경우)
- lead_time (lead_time이 길어질 수록 취소율이 늘어나는 경우)
- is_repeated_guest (호텔의 성향을 모르는 신규고객이 기대와 다른 서비스로 예약을 취소할경우 -> 이경우는 신규고객 여부의 문제보다는 다른 서비스들과 연계해서 조사해볼 필요가 있음)
"""

# 실제 신규고객이 기존고객보다 취소율이 높은지 확인
new_group = df.groupby('is_repeated_guest')['is_canceled'].mean()
new_group

"""### 특정 국가 고객 분석"""

# 특정 국가의 사람들이 취소율이 높은지 확인
country_group = df.groupby('country')['is_canceled'].mean()
country_group

country_count = df['country'].value_counts()
country_count

country_count.mean()

df['country_count'] = df['country'].map(country_count)
df['country_cancel_rate'] = df['country'].map(country_group)

df.head()

df['country_cancel'] = (df['country_count'] >= 500) & (df['country_cancel_rate'] > 0.27)
df.head()

# 예약건수가 500회이상, 취소율이 0.27보다 높은 국가의 비율이 전체국가의 40%이므로 의미있는 데이터로 판단
country_cancel = df['country_cancel'].sum()
total_num = df['country'].count()
result = country_cancel / total_num
result

df.groupby('country_cancel')['is_canceled'].mean()

cancel_result['country'] = 0.36

"""### lead_time 분석"""

# lead_time 확인
plt.boxplot(df['lead_time'])
plt.show()

corr_lead= df[['lead_time', 'is_canceled']].corr()

corr_lead

lead_norm = (df['lead_time'] - df['lead_time'].min()) / (df['lead_time'].max() - df['lead_time'].min())

df['lead_norm'] = lead_norm
df.head()

corr_value = df[['lead_norm', 'is_canceled']].corr()
corr_value

sns.kdeplot(df['lead_norm'])
plt.show()

lead_time_cut = pd.cut(
    df['lead_time'],
    bins=[0, 30, 900],
    labels=['0-30', '31+']
)

result = df.groupby(lead_time_cut)['is_canceled'].mean()
result

cancel_result['lead_time'] = 0.35

print(cancel_result)

"""### 신규고객 분석"""

df_new = df[df['is_repeated_guest'] == 0]
df_new

df_old = df[df['is_repeated_guest'] == 1]
df_old

# 첫 번째 가설의 상관관계 분석 - 신규
cols = ['is_canceled', 'required_car_parking_spaces', 'total_of_special_requests', 'is_same_to_reservation']
corr = df_new[cols].corr()    # 상관관계 계산

plt.figure(figsize=(15, 11))
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title("Correlation")
plt.show()

# 첫 번째 가설의 상관관계 분석 - 기존
cols = ['is_canceled', 'required_car_parking_spaces', 'total_of_special_requests', 'is_same_to_reservation']
corr = df_old[cols].corr()    # 상관관계 계산

plt.figure(figsize=(15, 11))
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title("Correlation")
plt.show()

same_room_group_new = df_new.groupby('is_same_to_reservation')['is_canceled'].mean()
same_room_group_old = df_old.groupby('is_same_to_reservation')['is_canceled'].mean()

print(same_room_group_new, same_room_group_old)

# 두 번째 가설의 상관관계 분석 - 신규
filtered_df = df_new[(df_new['is_prev_cancle_standard']) & (df_new['is_waiting_days_standard'])]

cols = ['is_canceled', 'is_segment_OTA', 'previous_cancellations', 'days_in_waiting_list']
corr = filtered_df[cols].corr()    # 상관관계 계산

plt.figure(figsize=(15, 11))
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title("Correlation")
plt.show()

# 두 번째 가설의 상관관계 분석 - 기존
filtered_df = df_old[(df_old['is_prev_cancle_standard']) & (df_old['is_waiting_days_standard'])]

cols = ['is_canceled', 'is_segment_OTA', 'previous_cancellations', 'days_in_waiting_list']
corr = filtered_df[cols].corr()    # 상관관계 계산

plt.figure(figsize=(15, 11))
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title("Correlation")
plt.show()

segment_group_new = df_new.groupby('is_segment_OTA')['is_canceled'].mean()
prev_cancel_new = df_new.groupby('previous_cancellations')['is_canceled'].mean()
segment_group_old = df_old.groupby('is_segment_OTA')['is_canceled'].mean()

print(segment_group_new, segment_group_old, prev_cancel_new)

df_new['previous_cancellations'].value_counts()

prev_cancel_cut = pd.cut(
    df_new['previous_cancellations'],
    bins=[-0.1, 0.5, 27],
    labels=['0', '1+']
)

prev_cancel_group = df_new.groupby(prev_cancel_cut)['is_canceled'].mean()
prev_cancel_group

# 신규고객의 취소빈도 비율

# prev_cancel = 0인 그룹
grp_0 = df_new[df_new['previous_cancellations'] == 0]
grp_0_cancel_count = grp_0['is_canceled'].sum()

# prev_cancel >= 1인 그룹
grp_1p = df_new[df_new['previous_cancellations'] >= 1]
grp_1p_cancel_count = grp_1p['is_canceled'].sum()

# 전체 취소 건수
total_cancel = df_new['is_canceled'].sum()

print(f"0인 그룹 취소건수: {grp_0_cancel_count}")
print(f"1+인 그룹 취소건수: {grp_1p_cancel_count}")
print(f"전체 대비 1+ 그룹 비중: {grp_1p_cancel_count/total_cancel:.2%}")

# 기존고객의 취소빈도 비율

# prev_cancel = 0인 그룹
grp_0 = df_old[df_old['previous_cancellations'] == 0]
grp_0_cancel_count = grp_0['is_canceled'].sum()

# prev_cancel >= 1인 그룹
grp_1p = df_old[df_old['previous_cancellations'] >= 1]
grp_1p_cancel_count = grp_1p['is_canceled'].sum()

# 전체 취소 건수
total_cancel = df_old['is_canceled'].sum()

print(f"0인 그룹 취소건수: {grp_0_cancel_count}")
print(f"1+인 그룹 취소건수: {grp_1p_cancel_count}")
print(f"전체 대비 1+ 그룹 비중: {grp_1p_cancel_count/total_cancel:.2%}")

# 특정 국가이면서 신규고객인경우

df_new.groupby('country_cancel')['is_canceled'].mean()

# 특정 국가이면서 기존고객인경우

df_old.groupby('country_cancel')['is_canceled'].mean()

# 신규고객의 lead_time
lead_time_cut = pd.cut(
    df_new['lead_time'],
    bins=[0, 30, 900],
    labels=['0-30', '31+']
)

result = df_new.groupby(lead_time_cut)['is_canceled'].mean()
result

# 기존고객의 lead_time
lead_time_cut = pd.cut(
    df_old['lead_time'],
    bins=[0, 30, 900],
    labels=['0-30', '31+']
)

result = df_old.groupby(lead_time_cut)['is_canceled'].mean()
result

"""### 세번째 가설 검증 결과
* 특정국가에서 예약하거나, lead_time이 30일 이상으로 길어질 경우 각각 취소율이 0.36, 0.35로서 전체 취소율 보다 높은 경향성을 보이는 것이 확인 됨
* 또한 같은 조건에서 기존고객보다 신규고객일 경우 더 높은 취소율을 보인다는 것이 확인되는데, 특히 기존 취소 경험이 1번 이상인 신규고객의 경우 취소율이 0.9에 육박하여 매우 높은 확률로 취소를 하는 것으로 보여짐
"""

print(cancel_result)

"""---

## 4. 결론
### 분석결과
* 분석결과 table  

|요인                     |취소율 |전체 평균 대비 차이|
|-------------------------|-------|-------------------|
|방 바뀜                  |0.32   |+5%p               |
|특정 세그먼트&채널       |0.35   |+8%p               |
|이전 취소 1회 이상       |0.68   |+41%p              |
|특정 국가(예약 500건이상)|0.36   |+9%p               |
|lead time 30일 이상      |0.35   |+8%p               |

* 현재 데이터 분석에서 전체 취소평균(0.27)보다 높은 취소율을 보이게 되는 요소는 다음과 같음
  
  - 예약된 방과 배정된 방이 다른 경우 (0.32)
  - 특정 시장 세그먼트 성향과 예약 채널 (0.35)
  - 예전에 취소한 이력이 1건이상이 존재하는 경우 (0.68)
  - 예약건수가 500회 이상인 특정 국가 (0.36)
  - lead_time이 30일 이상으로 길어질 경우 (0.35)
  - 신규고객일 경우 위의 모든 취소율이 기존고객보다 높은 경향.  
  단, 신규고객 단독으로서 취소율이 높은게 아닌 위의 요인이 결합된 상황에서 신규고객의 비율이 더 높은것으로 해석해야함

### 이유분석
* 예약된 방과 배정된 방이 다를경우 고객은 자신이 예약한 시점에서 기대했던 상황이 아니기 때문에 실망감을 느낄 수 있음  

* OTA(Online Travel Agent)는 온라인에서 예약하기 때문에 예약취소의 부담이 적으며 자유롭게 예약을 변경할 수 있다는 점에서 취소율이 높은것으로 생각됨  

* 예전에 취소 이력이 1건 이상 있는 고객은 예약 취소에 익숙하거나, 상습적으로 예약을 취소할 가능성이 있음.    
비록 이들의 수는 전체 대비 적지만, 1,000명 이상(약 1.5%)으로 집계되어 유의미한 분석 대상이라고 판단됨.  

* 특정 국가의 경우, 문화적 요인이나 거리, 국제·국내 상황에 따라 취소가 빈번할 수 있음.  
너무 소수의 데이터는 분석 가치가 떨어지므로, 500건 이상의 예약이 있는 국가들로 분석 대상을 제한했음.  
전체 국가를 분석하면 소폭 상승 또는 하락 가능성이 있음.  

* lead_time이 30일 이상되는 예약건수의 경우 입실까지의 시간이 길기 때문에 중간에 마음이 바뀌거나 사정이 생겨서 예약을 취소하는 건이 30일 이내의 예약보다는 더 많은 것으로 확인 됨  

* 신규 고객의 경우 호텔에 대한 경험이 없기 때문에 호텔의 서비스 상황에 대해 조금 더 민감하게 반응할 것으로 추정, 신규고객일 수록 위의 요인과 결합될 경우 취소율이 기존 고객보다 더 높은 것으로 확인됨

### 제안 및 개선방안
1. 예약된 방과 배정된 방이 다른 상황을 줄이기 위해, 예약시스템을 개편하고, 취소되는 방들을 빠르게 업데이트하여 정확한 객실 잔여 현황을 고객에게 제공할 수 있도록 개선 필요.  

2. OTA 세그먼트, lead time이 긴 문제, 상습적인 취소등의 경우 고객의 선택이고 호텔측에서 제어하기는 쉽지 않으므로, 취소 사유를 조사할 수 있는 시스템을 구축하고 정당한 사유 외에는 적절한 수수료 또는 패널티 적용을 검토.  

3. 취소율이 높은 국가들을 리서치하여 취소 사유를 파악하고, 빈번한 이유가 호텔 측에서 개선 가능한 사항인지 검토 필요.  

4. 신규 고객은 호텔의 중요한 성장 잠재고객이므로, 시장 조사 결과를 바탕으로 신규 고객을 대상으로 한 혜택 제공이나 이벤트를 기획해 긍정적인 호텔 경험을 심어줄 수 있는 전략이 필요.  

5. 기존 고객은 신규 고객과는 다른 혜택 제공으로 충성도 유지를 위한 방안을 마련할 필요
"""

